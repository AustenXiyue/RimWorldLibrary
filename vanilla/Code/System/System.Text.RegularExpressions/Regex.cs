using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.Serialization;
using System.Threading;

namespace System.Text.RegularExpressions;

/// <summary>Represents an immutable regular expression.</summary>
[Serializable]
public class Regex : ISerializable
{
	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal string pattern;

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal RegexRunnerFactory factory;

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal RegexOptions roptions;

	[NonSerialized]
	private static readonly TimeSpan MaximumMatchTimeout = TimeSpan.FromMilliseconds(2147483646.0);

	/// <summary>Specifies that a pattern-matching operation should not time out.</summary>
	[NonSerialized]
	public static readonly TimeSpan InfiniteMatchTimeout = Timeout.InfiniteTimeSpan;

	/// <summary>The maximum amount of time that can elapse in a pattern-matching operation before the operation times out.</summary>
	[OptionalField(VersionAdded = 2)]
	protected internal TimeSpan internalMatchTimeout;

	private const string DefaultMatchTimeout_ConfigKeyName = "REGEX_DEFAULT_MATCH_TIMEOUT";

	[NonSerialized]
	internal static readonly TimeSpan FallbackDefaultMatchTimeout = InfiniteMatchTimeout;

	[NonSerialized]
	internal static readonly TimeSpan DefaultMatchTimeout = InitDefaultMatchTimeout();

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal Hashtable caps;

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal Hashtable capnames;

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal string[] capslist;

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	protected internal int capsize;

	internal ExclusiveReference runnerref;

	internal SharedReference replref;

	internal RegexCode code;

	internal bool refsInitialized;

	internal static LinkedList<CachedCodeEntry> livecode = new LinkedList<CachedCodeEntry>();

	internal static int cacheSize = 15;

	internal const int MaxOptionShift = 10;

	/// <summary>Gets or sets the maximum number of entries in the current static cache of compiled regular expressions.</summary>
	/// <returns>The maximum number of entries in the static cache.</returns>
	/// <exception cref="T:System.ArgumentOutOfRangeException">The value in a set operation is less than zero.</exception>
	public static int CacheSize
	{
		get
		{
			return cacheSize;
		}
		set
		{
			if (value < 0)
			{
				throw new ArgumentOutOfRangeException("value");
			}
			cacheSize = value;
			if (livecode.Count <= cacheSize)
			{
				return;
			}
			lock (livecode)
			{
				while (livecode.Count > cacheSize)
				{
					livecode.RemoveLast();
				}
			}
		}
	}

	[CLSCompliant(false)]
	protected IDictionary Caps
	{
		get
		{
			Dictionary<int, int> dictionary = new Dictionary<int, int>();
			foreach (int key in caps.Keys)
			{
				dictionary.Add(key, (int)caps[key]);
			}
			return dictionary;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			caps = new Hashtable(value.Count);
			foreach (DictionaryEntry item in value)
			{
				caps[(int)item.Key] = (int)item.Value;
			}
		}
	}

	[CLSCompliant(false)]
	protected IDictionary CapNames
	{
		get
		{
			Dictionary<string, int> dictionary = new Dictionary<string, int>();
			foreach (string key in capnames.Keys)
			{
				dictionary.Add(key, (int)capnames[key]);
			}
			return dictionary;
		}
		set
		{
			if (value == null)
			{
				throw new ArgumentNullException("value");
			}
			capnames = new Hashtable(value.Count);
			foreach (DictionaryEntry item in value)
			{
				capnames[(string)item.Key] = (int)item.Value;
			}
		}
	}

	/// <summary>Gets the options that were passed into the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
	/// <returns>One or more members of the <see cref="T:System.Text.RegularExpressions.RegexOptions" /> enumeration that represent options that were passed to the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor </returns>
	public RegexOptions Options => roptions;

	/// <summary>Gets the time-out interval of the current instance.</summary>
	/// <returns>The maximum time interval that can elapse in a pattern-matching operation before a <see cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException" /> is thrown, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> if time-outs are disabled.</returns>
	public TimeSpan MatchTimeout => internalMatchTimeout;

	/// <summary>Gets a value that indicates whether the regular expression searches from right to left.</summary>
	/// <returns>true if the regular expression searches from right to left; otherwise, false.</returns>
	public bool RightToLeft => UseOptionR();

	/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class.</summary>
	protected Regex()
	{
		internalMatchTimeout = DefaultMatchTimeout;
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression.</summary>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred. </exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="pattern" /> is null.</exception>
	public Regex(string pattern)
		: this(pattern, RegexOptions.None, DefaultMatchTimeout, useCache: false)
	{
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern.</summary>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="options">A bitwise combination of the enumeration values that modify the regular expression. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred. </exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> contains an invalid flag.</exception>
	public Regex(string pattern, RegexOptions options)
		: this(pattern, options, DefaultMatchTimeout, useCache: false)
	{
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class for the specified regular expression, with options that modify the pattern and a value that specifies how long a pattern matching method should attempt a match before it times out.</summary>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="options">A bitwise combination of the enumeration values that modify the regular expression.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	public Regex(string pattern, RegexOptions options, TimeSpan matchTimeout)
		: this(pattern, options, matchTimeout, useCache: false)
	{
	}

	private Regex(string pattern, RegexOptions options, TimeSpan matchTimeout, bool useCache)
	{
		CachedCodeEntry cachedCodeEntry = null;
		string text = null;
		if (pattern == null)
		{
			throw new ArgumentNullException("pattern");
		}
		if (options < RegexOptions.None || (int)options >> 10 != 0)
		{
			throw new ArgumentOutOfRangeException("options");
		}
		if ((options & RegexOptions.ECMAScript) != 0 && (options & ~(RegexOptions.IgnoreCase | RegexOptions.Multiline | RegexOptions.Compiled | RegexOptions.ECMAScript | RegexOptions.CultureInvariant)) != 0)
		{
			throw new ArgumentOutOfRangeException("options");
		}
		ValidateMatchTimeout(matchTimeout);
		text = (((options & RegexOptions.CultureInvariant) == 0) ? CultureInfo.CurrentCulture.ToString() : CultureInfo.InvariantCulture.ToString());
		string[] array = new string[5];
		int num = (int)options;
		array[0] = num.ToString(NumberFormatInfo.InvariantInfo);
		array[1] = ":";
		array[2] = text;
		array[3] = ":";
		array[4] = pattern;
		string key = string.Concat(array);
		cachedCodeEntry = LookupCachedAndUpdate(key);
		this.pattern = pattern;
		roptions = options;
		internalMatchTimeout = matchTimeout;
		if (cachedCodeEntry == null)
		{
			RegexTree regexTree = RegexParser.Parse(pattern, roptions);
			capnames = regexTree._capnames;
			capslist = regexTree._capslist;
			code = RegexWriter.Write(regexTree);
			caps = code._caps;
			capsize = code._capsize;
			InitializeReferences();
			regexTree = null;
			if (useCache)
			{
				cachedCodeEntry = CacheCode(key);
			}
		}
		else
		{
			caps = cachedCodeEntry._caps;
			capnames = cachedCodeEntry._capnames;
			capslist = cachedCodeEntry._capslist;
			capsize = cachedCodeEntry._capsize;
			code = cachedCodeEntry._code;
			factory = cachedCodeEntry._factory;
			runnerref = cachedCodeEntry._runnerref;
			replref = cachedCodeEntry._replref;
			refsInitialized = true;
		}
		if (UseOptionC() && factory == null)
		{
			factory = Compile(code, roptions);
			if (useCache)
			{
				cachedCodeEntry?.AddCompiled(factory);
			}
			code = null;
		}
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.Text.RegularExpressions.Regex" /> class by using serialized data.</summary>
	/// <param name="info">The object that contains a serialized pattern and <see cref="T:System.Text.RegularExpressions.RegexOptions" />  information.</param>
	/// <param name="context">The destination for this serialization. (This parameter is not used; specify null.)</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred. </exception>
	/// <exception cref="T:System.ArgumentNullException">The pattern that <paramref name="info" /> contains is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="info" /> contains an invalid <see cref="T:System.Text.RegularExpressions.RegexOptions" />  flag.</exception>
	protected Regex(SerializationInfo info, StreamingContext context)
		: this(info.GetString("pattern"), (RegexOptions)info.GetInt32("options"))
	{
		try
		{
			long @int = info.GetInt64("matchTimeout");
			TimeSpan matchTimeout = new TimeSpan(@int);
			ValidateMatchTimeout(matchTimeout);
			internalMatchTimeout = matchTimeout;
		}
		catch (SerializationException)
		{
		}
	}

	/// <summary>Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data necessary to deserialize the current <see cref="T:System.Text.RegularExpressions.Regex" /> object.</summary>
	/// <param name="si">The object to populate with serialization information.</param>
	/// <param name="context">The place to store and retrieve serialized data. This parameter is reserved for future use.</param>
	void ISerializable.GetObjectData(SerializationInfo si, StreamingContext context)
	{
		si.AddValue("pattern", ToString());
		si.AddValue("options", Options);
		si.AddValue("matchTimeout", MatchTimeout.Ticks);
	}

	/// <summary>Checks whether a time-out interval is within an acceptable range.</summary>
	/// <param name="matchTimeout">The time-out interval to check.</param>
	protected internal static void ValidateMatchTimeout(TimeSpan matchTimeout)
	{
		if (InfiniteMatchTimeout == matchTimeout || (TimeSpan.Zero < matchTimeout && matchTimeout <= MaximumMatchTimeout))
		{
			return;
		}
		throw new ArgumentOutOfRangeException("matchTimeout");
	}

	private static TimeSpan InitDefaultMatchTimeout()
	{
		object data = AppDomain.CurrentDomain.GetData("REGEX_DEFAULT_MATCH_TIMEOUT");
		if (data == null)
		{
			return FallbackDefaultMatchTimeout;
		}
		if (!(data is TimeSpan timeSpan))
		{
			throw new InvalidCastException(global::SR.GetString("AppDomain data '{0}' contains an invalid value or object for specifying a default matching timeout for System.Text.RegularExpressions.Regex.", "REGEX_DEFAULT_MATCH_TIMEOUT"));
		}
		try
		{
			ValidateMatchTimeout(timeSpan);
			return timeSpan;
		}
		catch (ArgumentOutOfRangeException)
		{
			throw new ArgumentOutOfRangeException(global::SR.GetString("AppDomain data '{0}' contains an invalid value or object for specifying a default matching timeout for System.Text.RegularExpressions.Regex.", "REGEX_DEFAULT_MATCH_TIMEOUT"));
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	internal RegexRunnerFactory Compile(RegexCode code, RegexOptions roptions)
	{
		return RegexCompiler.Compile(code, roptions);
	}

	/// <summary>Escapes a minimal set of characters (\, *, +, ?, |, {, [, (,), ^, $,., #, and white space) by replacing them with their escape codes. This instructs the regular expression engine to interpret these characters literally rather than as metacharacters.</summary>
	/// <returns>A string of characters with metacharacters converted to their escaped form.</returns>
	/// <param name="str">The input string that contains the text to convert. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="str" /> is null.</exception>
	public static string Escape(string str)
	{
		if (str == null)
		{
			throw new ArgumentNullException("str");
		}
		return RegexParser.Escape(str);
	}

	/// <summary>Converts any escaped characters in the input string.</summary>
	/// <returns>A string of characters with any escaped characters converted to their unescaped form.</returns>
	/// <param name="str">The input string containing the text to convert. </param>
	/// <exception cref="T:System.ArgumentException">
	///   <paramref name="str" /> includes an unrecognized escape sequence.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="str" /> is null.</exception>
	public static string Unescape(string str)
	{
		if (str == null)
		{
			throw new ArgumentNullException("str");
		}
		return RegexParser.Unescape(str);
	}

	/// <summary>Returns the regular expression pattern that was passed into the Regex constructor.</summary>
	/// <returns>The <paramref name="pattern" /> parameter that was passed into the Regex constructor.</returns>
	public override string ToString()
	{
		return pattern;
	}

	/// <summary>Returns an array of capturing group names for the regular expression.</summary>
	/// <returns>A string array of group names.</returns>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode" />
	/// </PermissionSet>
	public string[] GetGroupNames()
	{
		string[] array;
		if (capslist == null)
		{
			int num = capsize;
			array = new string[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = Convert.ToString(i, CultureInfo.InvariantCulture);
			}
		}
		else
		{
			array = new string[capslist.Length];
			Array.Copy(capslist, 0, array, 0, capslist.Length);
		}
		return array;
	}

	/// <summary>Returns an array of capturing group numbers that correspond to group names in an array.</summary>
	/// <returns>An integer array of group numbers.</returns>
	public int[] GetGroupNumbers()
	{
		int[] array;
		if (caps == null)
		{
			int num = capsize;
			array = new int[num];
			for (int i = 0; i < num; i++)
			{
				array[i] = i;
			}
		}
		else
		{
			array = new int[caps.Count];
			IDictionaryEnumerator enumerator = caps.GetEnumerator();
			while (enumerator.MoveNext())
			{
				array[(int)enumerator.Value] = (int)enumerator.Key;
			}
		}
		return array;
	}

	/// <summary>Gets the group name that corresponds to the specified group number.</summary>
	/// <returns>A string that contains the group name associated with the specified group number. If there is no group name that corresponds to <paramref name="i" />, the method returns <see cref="F:System.String.Empty" />.</returns>
	/// <param name="i">The group number to convert to the corresponding group name. </param>
	public string GroupNameFromNumber(int i)
	{
		if (capslist == null)
		{
			if (i >= 0 && i < capsize)
			{
				return i.ToString(CultureInfo.InvariantCulture);
			}
			return string.Empty;
		}
		if (caps != null)
		{
			object obj = caps[i];
			if (obj == null)
			{
				return string.Empty;
			}
			i = (int)obj;
		}
		if (i >= 0 && i < capslist.Length)
		{
			return capslist[i];
		}
		return string.Empty;
	}

	/// <summary>Returns the group number that corresponds to the specified group name.</summary>
	/// <returns>The group number that corresponds to the specified group name, or -1 if <paramref name="name" /> is not a valid group name.</returns>
	/// <param name="name">The group name to convert to the corresponding group number. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="name" /> is null.</exception>
	public int GroupNumberFromName(string name)
	{
		int num = -1;
		if (name == null)
		{
			throw new ArgumentNullException("name");
		}
		if (capnames != null)
		{
			object obj = capnames[name];
			if (obj == null)
			{
				return -1;
			}
			return (int)obj;
		}
		num = 0;
		foreach (char c in name)
		{
			if (c > '9' || c < '0')
			{
				return -1;
			}
			num *= 10;
			num += c - 48;
		}
		if (num >= 0 && num < capsize)
		{
			return num;
		}
		return -1;
	}

	/// <summary>Indicates whether the specified regular expression finds a match in the specified input string.</summary>
	/// <returns>true if the regular expression finds a match; otherwise, false.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null. </exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static bool IsMatch(string input, string pattern)
	{
		return IsMatch(input, pattern, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options.</summary>
	/// <returns>true if the regular expression finds a match; otherwise, false.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" />  value.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static bool IsMatch(string input, string pattern, RegexOptions options)
	{
		return IsMatch(input, pattern, options, DefaultMatchTimeout);
	}

	/// <summary>Indicates whether the specified regular expression finds a match in the specified input string, using the specified matching options and time-out interval.</summary>
	/// <returns>true if the regular expression finds a match; otherwise, false.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid <see cref="T:System.Text.RegularExpressions.RegexOptions" /> value.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred.</exception>
	public static bool IsMatch(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).IsMatch(input);
	}

	/// <summary>Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in a specified input string.</summary>
	/// <returns>true if the regular expression finds a match; otherwise, false.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public bool IsMatch(string input)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return IsMatch(input, UseOptionR() ? input.Length : 0);
	}

	/// <summary>Indicates whether the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor finds a match in the specified input string, beginning at the specified starting position in the string.</summary>
	/// <returns>true if the regular expression finds a match; otherwise, false.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="startat">The character position at which to start the search. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public bool IsMatch(string input, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Run(quick: true, -1, input, 0, input.Length, startat) == null;
	}

	/// <summary>Searches the specified input string for the first occurrence of the specified regular expression.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static Match Match(string input, string pattern)
	{
		return Match(input, pattern, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static Match Match(string input, string pattern, RegexOptions options)
	{
		return Match(input, pattern, options, DefaultMatchTimeout);
	}

	/// <summary>Searches the input string for the first occurrence of the specified regular expression, using the specified matching options and time-out interval.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	public static Match Match(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).Match(input);
	}

	/// <summary>Searches the specified input string for the first occurrence of the regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public Match Match(string input)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Match(input, UseOptionR() ? input.Length : 0);
	}

	/// <summary>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position in the string.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="startat">The zero-based character position at which to start the search. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public Match Match(string input, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Run(quick: false, -1, input, 0, input.Length, startat);
	}

	/// <summary>Searches the input string for the first occurrence of a regular expression, beginning at the specified starting position and searching only the specified number of characters.</summary>
	/// <returns>An object that contains information about the match.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="beginning">The zero-based character position in the input string that defines the leftmost position to be searched. </param>
	/// <param name="length">The number of characters in the substring to include in the search. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="beginning" /> is less than zero or greater than the length of <paramref name="input" />.-or-<paramref name="length" /> is less than zero or greater than the length of <paramref name="input" />.-or-<paramref name="beginning" />+<paramref name="length" />– 1 identifies a position that is outside the range of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public Match Match(string input, int beginning, int length)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Run(quick: false, -1, input, beginning, length, UseOptionR() ? (beginning + length) : beginning);
	}

	/// <summary>Searches the specified input string for all occurrences of a specified regular expression.</summary>
	/// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static MatchCollection Matches(string input, string pattern)
	{
		return Matches(input, pattern, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options.</summary>
	/// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="options">A bitwise combination of the enumeration values that specify options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static MatchCollection Matches(string input, string pattern, RegexOptions options)
	{
		return Matches(input, pattern, options, DefaultMatchTimeout);
	}

	/// <summary>Searches the specified input string for all occurrences of a specified regular expression, using the specified matching options and time-out interval.</summary>
	/// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="options">A bitwise combination of the enumeration values that specify options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	public static MatchCollection Matches(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).Matches(input);
	}

	/// <summary>Searches the specified input string for all occurrences of a regular expression.</summary>
	/// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public MatchCollection Matches(string input)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Matches(input, UseOptionR() ? input.Length : 0);
	}

	/// <summary>Searches the specified input string for all occurrences of a regular expression, beginning at the specified starting position in the string.</summary>
	/// <returns>A collection of the <see cref="T:System.Text.RegularExpressions.Match" /> objects found by the search. If no matches are found, the method returns an empty collection object.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="startat">The character position in the input string at which to start the search. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public MatchCollection Matches(string input, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return new MatchCollection(this, input, 0, input.Length, startat);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. </summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="replacement">The replacement string. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string Replace(string input, string pattern, string replacement)
	{
		return Replace(input, pattern, replacement, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. Specified options modify the matching operation. </summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="replacement">The replacement string. </param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string Replace(string input, string pattern, string replacement, RegexOptions options)
	{
		return Replace(input, pattern, replacement, options, DefaultMatchTimeout);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a specified replacement string. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="replacement">The replacement string.</param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	public static string Replace(string input, string pattern, string replacement, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).Replace(input, replacement);
	}

	/// <summary>In a specified input string, replaces all strings that match a regular expression pattern with a specified replacement string. </summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="replacement">The replacement string. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, string replacement)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Replace(input, replacement, -1, UseOptionR() ? input.Length : 0);
	}

	/// <summary>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string. </summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="replacement">The replacement string. </param>
	/// <param name="count">The maximum number of times the replacement can occur. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, string replacement, int count)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Replace(input, replacement, count, UseOptionR() ? input.Length : 0);
	}

	/// <summary>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a specified replacement string. </summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="replacement">The replacement string. </param>
	/// <param name="count">Maximum number of times the replacement can occur. </param>
	/// <param name="startat">The character position in the input string where the search begins. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="replacement" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, string replacement, int count, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		if (replacement == null)
		{
			throw new ArgumentNullException("replacement");
		}
		RegexReplacement regexReplacement = (RegexReplacement)replref.Get();
		if (regexReplacement == null || !regexReplacement.Pattern.Equals(replacement))
		{
			regexReplacement = RegexParser.ParseReplacement(replacement, caps, capsize, capnames, roptions);
			replref.Cache(regexReplacement);
		}
		return regexReplacement.Replace(this, input, count, startat);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate.</summary>
	/// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string Replace(string input, string pattern, MatchEvaluator evaluator)
	{
		return Replace(input, pattern, evaluator, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. Specified options modify the matching operation.</summary>
	/// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string. </param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options)
	{
		return Replace(input, pattern, evaluator, options, DefaultMatchTimeout);
	}

	/// <summary>In a specified input string, replaces all substrings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
	/// <returns>A new string that is identical to the input string, except that the replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
	/// <param name="options">A bitwise combination of enumeration values that provide options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" />, <paramref name="pattern" />, or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	public static string Replace(string input, string pattern, MatchEvaluator evaluator, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).Replace(input, evaluator);
	}

	/// <summary>In a specified input string, replaces all strings that match a specified regular expression with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. </summary>
	/// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, MatchEvaluator evaluator)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Replace(input, evaluator, -1, UseOptionR() ? input.Length : 0);
	}

	/// <summary>In a specified input string, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. </summary>
	/// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
	/// <param name="count">The maximum number of times the replacement will occur. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, MatchEvaluator evaluator, int count)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Replace(input, evaluator, count, UseOptionR() ? input.Length : 0);
	}

	/// <summary>In a specified input substring, replaces a specified maximum number of strings that match a regular expression pattern with a string returned by a <see cref="T:System.Text.RegularExpressions.MatchEvaluator" /> delegate. </summary>
	/// <returns>A new string that is identical to the input string, except that a replacement string takes the place of each matched string.</returns>
	/// <param name="input">The string to search for a match. </param>
	/// <param name="evaluator">A custom method that examines each match and returns either the original matched string or a replacement string.</param>
	/// <param name="count">The maximum number of times the replacement will occur. </param>
	/// <param name="startat">The character position in the input string where the search begins. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="evaluator" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string Replace(string input, MatchEvaluator evaluator, int count, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return RegexReplacement.Replace(evaluator, this, input, count, startat);
	}

	/// <summary>Splits an input string into an array of substrings at the positions defined by a regular expression pattern.</summary>
	/// <returns>An array of strings.</returns>
	/// <param name="input">The string to split. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string[] Split(string input, string pattern)
	{
		return Split(input, pattern, RegexOptions.None, DefaultMatchTimeout);
	}

	/// <summary>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern. Specified options modify the matching operation.</summary>
	/// <returns>An array of strings.</returns>
	/// <param name="input">The string to split. </param>
	/// <param name="pattern">The regular expression pattern to match. </param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching. </param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static string[] Split(string input, string pattern, RegexOptions options)
	{
		return Split(input, pattern, options, DefaultMatchTimeout);
	}

	/// <summary>Splits an input string into an array of substrings at the positions defined by a specified regular expression pattern. Additional parameters specify options that modify the matching operation and a time-out interval if no match is found.</summary>
	/// <returns>A string array.</returns>
	/// <param name="input">The string to split.</param>
	/// <param name="pattern">The regular expression pattern to match.</param>
	/// <param name="options">A bitwise combination of the enumeration values that provide options for matching.</param>
	/// <param name="matchTimeout">A time-out interval, or <see cref="F:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout" /> to indicate that the method should not time out.</param>
	/// <exception cref="T:System.ArgumentException">A regular expression parsing error occurred.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> or <paramref name="pattern" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="options" /> is not a valid bitwise combination of <see cref="T:System.Text.RegularExpressions.RegexOptions" /> values.-or-<paramref name="matchTimeout" /> is negative, zero, or greater than approximately 24 days.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	public static string[] Split(string input, string pattern, RegexOptions options, TimeSpan matchTimeout)
	{
		return new Regex(pattern, options, matchTimeout, useCache: true).Split(input);
	}

	/// <summary>Splits an input string into an array of substrings at the positions defined by a regular expression pattern specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
	/// <returns>An array of strings.</returns>
	/// <param name="input">The string to split. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string[] Split(string input)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return Split(input, 0, UseOptionR() ? input.Length : 0);
	}

	/// <summary>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor.</summary>
	/// <returns>An array of strings.</returns>
	/// <param name="input">The string to be split. </param>
	/// <param name="count">The maximum number of times the split can occur. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string[] Split(string input, int count)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return RegexReplacement.Split(this, input, count, UseOptionR() ? input.Length : 0);
	}

	/// <summary>Splits an input string a specified maximum number of times into an array of substrings, at the positions defined by a regular expression specified in the <see cref="T:System.Text.RegularExpressions.Regex" /> constructor. The search for the regular expression pattern starts at a specified character position in the input string.</summary>
	/// <returns>An array of strings.</returns>
	/// <param name="input">The string to be split. </param>
	/// <param name="count">The maximum number of times the split can occur. </param>
	/// <param name="startat">The character position in the input string where the search will begin. </param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="input" /> is null.</exception>
	/// <exception cref="T:System.ArgumentOutOfRangeException">
	///   <paramref name="startat" /> is less than zero or greater than the length of <paramref name="input" />.</exception>
	/// <exception cref="T:System.Text.RegularExpressions.RegexMatchTimeoutException">A time-out occurred. For more information about time-outs, see the Remarks section.</exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public string[] Split(string input, int count, int startat)
	{
		if (input == null)
		{
			throw new ArgumentNullException("input");
		}
		return RegexReplacement.Split(this, input, count, startat);
	}

	/// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly.</summary>
	/// <param name="regexinfos">An array that describes the regular expressions to compile. </param>
	/// <param name="assemblyname">The file name of the assembly. </param>
	/// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.-or-The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is null. </exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname)
	{
		CompileToAssemblyInternal(regexinfos, assemblyname, null, null);
	}

	/// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects to a named assembly with the specified attributes.</summary>
	/// <param name="regexinfos">An array that describes the regular expressions to compile. </param>
	/// <param name="assemblyname">The file name of the assembly. </param>
	/// <param name="attributes">An array that defines the attributes to apply to the assembly. </param>
	/// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.-or-The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is null. </exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes)
	{
		CompileToAssemblyInternal(regexinfos, assemblyname, attributes, null);
	}

	/// <summary>Compiles one or more specified <see cref="T:System.Text.RegularExpressions.Regex" /> objects and a specified resource file to a named assembly with the specified attributes.</summary>
	/// <param name="regexinfos">An array that describes the regular expressions to compile. </param>
	/// <param name="assemblyname">The file name of the assembly. </param>
	/// <param name="attributes">An array that defines the attributes to apply to the assembly. </param>
	/// <param name="resourceFile">The name of the Win32 resource file to include in the assembly. </param>
	/// <exception cref="T:System.ArgumentException">The value of the <paramref name="assemblyname" /> parameter's <see cref="P:System.Reflection.AssemblyName.Name" /> property is an empty or null string.-or-The regular expression pattern of one or more objects in <paramref name="regexinfos" /> contains invalid syntax.</exception>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="assemblyname" /> or <paramref name="regexinfos" /> is null. </exception>
	/// <exception cref="T:System.Runtime.InteropServices.COMException">The <paramref name="resourceFile" /> parameter designates an invalid Win32 resource file.</exception>
	/// <exception cref="T:System.IO.FileNotFoundException">The file designated by the <paramref name="resourceFile" /> parameter cannot be found.  </exception>
	/// <PermissionSet>
	///   <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Unrestricted="true" />
	///   <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="ControlEvidence" />
	/// </PermissionSet>
	public static void CompileToAssembly(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile)
	{
		CompileToAssemblyInternal(regexinfos, assemblyname, attributes, resourceFile);
	}

	private static void CompileToAssemblyInternal(RegexCompilationInfo[] regexinfos, AssemblyName assemblyname, CustomAttributeBuilder[] attributes, string resourceFile)
	{
		if (assemblyname == null)
		{
			throw new ArgumentNullException("assemblyname");
		}
		if (regexinfos == null)
		{
			throw new ArgumentNullException("regexinfos");
		}
		RegexCompiler.CompileToAssembly(regexinfos, assemblyname, attributes, resourceFile);
	}

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method. </summary>
	/// <exception cref="T:System.NotSupportedException">References have already been initialized. </exception>
	protected void InitializeReferences()
	{
		if (refsInitialized)
		{
			throw new NotSupportedException(global::SR.GetString("This operation is only allowed once per object."));
		}
		refsInitialized = true;
		runnerref = new ExclusiveReference();
		replref = new SharedReference();
	}

	internal Match Run(bool quick, int prevlen, string input, int beginning, int length, int startat)
	{
		RegexRunner regexRunner = null;
		if (startat < 0 || startat > input.Length)
		{
			throw new ArgumentOutOfRangeException("start", global::SR.GetString("Start index cannot be less than 0 or greater than input length."));
		}
		if (length < 0 || length > input.Length)
		{
			throw new ArgumentOutOfRangeException("length", global::SR.GetString("Length cannot be less than 0 or exceed input length."));
		}
		regexRunner = (RegexRunner)runnerref.Get();
		if (regexRunner == null)
		{
			regexRunner = ((factory == null) ? new RegexInterpreter(code, UseOptionInvariant() ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture) : factory.CreateInstance());
		}
		try
		{
			return regexRunner.Scan(this, input, beginning, beginning + length, startat, prevlen, quick, internalMatchTimeout);
		}
		finally
		{
			runnerref.Release(regexRunner);
		}
	}

	private static CachedCodeEntry LookupCachedAndUpdate(string key)
	{
		lock (livecode)
		{
			for (LinkedListNode<CachedCodeEntry> linkedListNode = livecode.First; linkedListNode != null; linkedListNode = linkedListNode.Next)
			{
				if (linkedListNode.Value._key == key)
				{
					livecode.Remove(linkedListNode);
					livecode.AddFirst(linkedListNode);
					return linkedListNode.Value;
				}
			}
		}
		return null;
	}

	private CachedCodeEntry CacheCode(string key)
	{
		CachedCodeEntry cachedCodeEntry = null;
		lock (livecode)
		{
			for (LinkedListNode<CachedCodeEntry> linkedListNode = livecode.First; linkedListNode != null; linkedListNode = linkedListNode.Next)
			{
				if (linkedListNode.Value._key == key)
				{
					livecode.Remove(linkedListNode);
					livecode.AddFirst(linkedListNode);
					return linkedListNode.Value;
				}
			}
			if (cacheSize != 0)
			{
				cachedCodeEntry = new CachedCodeEntry(key, capnames, capslist, code, caps, capsize, runnerref, replref);
				livecode.AddFirst(cachedCodeEntry);
				if (livecode.Count > cacheSize)
				{
					livecode.RemoveLast();
				}
			}
		}
		return cachedCodeEntry;
	}

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
	/// <returns>true if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.Compiled" /> option; otherwise, false.</returns>
	protected bool UseOptionC()
	{
		return false;
	}

	/// <summary>Used by a <see cref="T:System.Text.RegularExpressions.Regex" /> object generated by the <see cref="Overload:System.Text.RegularExpressions.Regex.CompileToAssembly" /> method.</summary>
	/// <returns>true if the <see cref="P:System.Text.RegularExpressions.Regex.Options" /> property contains the <see cref="F:System.Text.RegularExpressions.RegexOptions.RightToLeft" /> option; otherwise, false.</returns>
	protected bool UseOptionR()
	{
		return (roptions & RegexOptions.RightToLeft) != 0;
	}

	internal bool UseOptionInvariant()
	{
		return (roptions & RegexOptions.CultureInvariant) != 0;
	}
}
