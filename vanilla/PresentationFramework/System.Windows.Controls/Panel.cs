using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Windows.Controls.Primitives;
using System.Windows.Markup;
using System.Windows.Media;
using MS.Internal.Controls;
using MS.Internal.KnownBoxes;
using MS.Internal.PresentationFramework;

namespace System.Windows.Controls;

/// <summary>Provides a base class for all <see cref="T:System.Windows.Controls.Panel" /> elements. Use <see cref="T:System.Windows.Controls.Panel" /> elements to position and arrange child objects in Windows Presentation Foundation (WPF) applications. </summary>
[Localizability(LocalizationCategory.Ignore)]
[ContentProperty("Children")]
public abstract class Panel : FrameworkElement, IAddChild
{
	[Flags]
	private enum BoolField : byte
	{
		IsZStateDirty = 1,
		IsZStateDiverse = 2,
		IsVirtualizing = 4,
		HasMeasured = 8,
		IsPixelBased = 0x10,
		InRecyclingMode = 0x20,
		MustDisableVirtualization = 0x40,
		MeasureCaches = 0x80
	}

	/// <summary>Identifies the <see cref="P:System.Windows.Controls.Panel.Background" /> dependency property. </summary>
	/// <returns>The identifier for the <see cref="P:System.Windows.Controls.Panel.Background" /> dependency property.</returns>
	[CommonDependencyProperty]
	public static readonly DependencyProperty BackgroundProperty = DependencyProperty.Register("Background", typeof(Brush), typeof(Panel), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsRender | FrameworkPropertyMetadataOptions.SubPropertiesDoNotAffectRender));

	/// <summary>Identifies the <see cref="P:System.Windows.Controls.Panel.IsItemsHost" /> dependency property. </summary>
	/// <returns>The identifier for the <see cref="P:System.Windows.Controls.Panel.IsItemsHost" /> dependency property.</returns>
	public static readonly DependencyProperty IsItemsHostProperty = DependencyProperty.Register("IsItemsHost", typeof(bool), typeof(Panel), new FrameworkPropertyMetadata(BooleanBoxes.FalseBox, FrameworkPropertyMetadataOptions.NotDataBindable, OnIsItemsHostChanged));

	private UIElementCollection _uiElementCollection;

	private ItemContainerGenerator _itemContainerGenerator;

	private BoolField _boolFieldStore;

	private const int c_zDefaultValue = 0;

	private int _zConsonant;

	private int[] _zLut;

	/// <summary>Identifies the <see cref="P:System.Windows.Controls.Panel.ZIndex" /> attached property.</summary>
	/// <returns>The identifier for the <see cref="P:System.Windows.Controls.Panel.ZIndex" /> attached property.</returns>
	public static readonly DependencyProperty ZIndexProperty = DependencyProperty.RegisterAttached("ZIndex", typeof(int), typeof(Panel), new FrameworkPropertyMetadata(0, OnZIndexPropertyChanged));

	/// <summary>Gets or sets a <see cref="T:System.Windows.Media.Brush" /> that is used to fill the area between the borders of a <see cref="T:System.Windows.Controls.Panel" />.  </summary>
	/// <returns>A <see cref="T:System.Windows.Media.Brush" />. This default value is null.</returns>
	public Brush Background
	{
		get
		{
			return (Brush)GetValue(BackgroundProperty);
		}
		set
		{
			SetValue(BackgroundProperty, value);
		}
	}

	/// <summary>Gets an enumerator that can iterate the logical child elements of this <see cref="T:System.Windows.Controls.Panel" /> element. </summary>
	/// <returns>An <see cref="T:System.Collections.IEnumerator" />. This property has no default value.</returns>
	protected internal override IEnumerator LogicalChildren
	{
		get
		{
			if (VisualChildrenCount == 0 || IsItemsHost)
			{
				return EmptyEnumerator.Instance;
			}
			return Children.GetEnumerator();
		}
	}

	/// <summary>Gets a <see cref="T:System.Windows.Controls.UIElementCollection" /> of child elements of this <see cref="T:System.Windows.Controls.Panel" />. </summary>
	/// <returns>A <see cref="T:System.Windows.Controls.UIElementCollection" />. The default is an empty <see cref="T:System.Windows.Controls.UIElementCollection" />.</returns>
	[DesignerSerializationVisibility(DesignerSerializationVisibility.Content)]
	public UIElementCollection Children => InternalChildren;

	/// <summary>Gets or sets a value that indicates that this <see cref="T:System.Windows.Controls.Panel" /> is a container for user interface (UI) items that are generated by an <see cref="T:System.Windows.Controls.ItemsControl" />.  </summary>
	/// <returns>true if this instance of <see cref="T:System.Windows.Controls.Panel" /> is an items host; otherwise, false. The default value is false.</returns>
	[Bindable(false)]
	[Category("Behavior")]
	public bool IsItemsHost
	{
		get
		{
			return (bool)GetValue(IsItemsHostProperty);
		}
		set
		{
			SetValue(IsItemsHostProperty, BooleanBoxes.Box(value));
		}
	}

	/// <summary>The <see cref="T:System.Windows.Controls.Orientation" /> of the panel, if the panel supports layout in only a single dimension.</summary>
	/// <returns>The <see cref="T:System.Windows.Controls.Orientation" /> of the panel. This property has no default value.</returns>
	public Orientation LogicalOrientationPublic => LogicalOrientation;

	/// <summary>The <see cref="T:System.Windows.Controls.Orientation" /> of the panel, if the panel supports layout in only a single dimension.</summary>
	/// <returns>The <see cref="T:System.Windows.Controls.Orientation" /> of the panel. This property has no default value.</returns>
	protected internal virtual Orientation LogicalOrientation => Orientation.Vertical;

	/// <summary>Gets a value that indicates whether this <see cref="T:System.Windows.Controls.Panel" /> arranges its descendants in a single dimension.</summary>
	/// <returns>true if the orientation of the <see cref="T:System.Windows.Controls.Panel" /> is in one dimension; otherwise, false.</returns>
	public bool HasLogicalOrientationPublic => HasLogicalOrientation;

	/// <summary>Gets a value that indicates whether this <see cref="T:System.Windows.Controls.Panel" /> arranges its descendants in a single dimension.</summary>
	/// <returns>true if the orientation of the <see cref="T:System.Windows.Controls.Panel" /> is in one dimension; otherwise, false.</returns>
	protected internal virtual bool HasLogicalOrientation => false;

	/// <summary>Gets a <see cref="T:System.Windows.Controls.UIElementCollection" /> of child elements. </summary>
	/// <returns>An ordered collection of <see cref="T:System.Windows.UIElement" /> objects. This property has no default value.</returns>
	protected internal UIElementCollection InternalChildren
	{
		get
		{
			VerifyBoundState();
			if (IsItemsHost)
			{
				EnsureGenerator();
			}
			else if (_uiElementCollection == null)
			{
				EnsureEmptyChildren(this);
			}
			return _uiElementCollection;
		}
	}

	/// <summary>Gets the number of child <see cref="T:System.Windows.Media.Visual" /> objects in this instance of <see cref="T:System.Windows.Controls.Panel" />.</summary>
	/// <returns>The number of child <see cref="T:System.Windows.Media.Visual" /> objects.</returns>
	protected override int VisualChildrenCount
	{
		get
		{
			if (_uiElementCollection == null)
			{
				return 0;
			}
			return _uiElementCollection.Count;
		}
	}

	internal IItemContainerGenerator Generator => _itemContainerGenerator;

	internal bool VSP_IsVirtualizing
	{
		get
		{
			return GetBoolField(BoolField.IsVirtualizing);
		}
		set
		{
			SetBoolField(BoolField.IsVirtualizing, value);
		}
	}

	internal bool VSP_HasMeasured
	{
		get
		{
			return GetBoolField(BoolField.HasMeasured);
		}
		set
		{
			SetBoolField(BoolField.HasMeasured, value);
		}
	}

	internal bool VSP_MustDisableVirtualization
	{
		get
		{
			return GetBoolField(BoolField.MustDisableVirtualization);
		}
		set
		{
			SetBoolField(BoolField.MustDisableVirtualization, value);
		}
	}

	internal bool VSP_IsPixelBased
	{
		get
		{
			return GetBoolField(BoolField.IsPixelBased);
		}
		set
		{
			SetBoolField(BoolField.IsPixelBased, value);
		}
	}

	internal bool VSP_InRecyclingMode
	{
		get
		{
			return GetBoolField(BoolField.InRecyclingMode);
		}
		set
		{
			SetBoolField(BoolField.InRecyclingMode, value);
		}
	}

	internal bool VSP_MeasureCaches
	{
		get
		{
			return GetBoolField(BoolField.MeasureCaches);
		}
		set
		{
			SetBoolField(BoolField.MeasureCaches, value);
		}
	}

	internal bool IsDataBound
	{
		get
		{
			if (IsItemsHost)
			{
				return _itemContainerGenerator != null;
			}
			return false;
		}
	}

	internal override int EffectiveValuesInitialSize => 9;

	private bool IsZStateDirty
	{
		get
		{
			return GetBoolField(BoolField.IsZStateDirty);
		}
		set
		{
			SetBoolField(BoolField.IsZStateDirty, value);
		}
	}

	private bool IsZStateDiverse
	{
		get
		{
			return GetBoolField(BoolField.IsZStateDiverse);
		}
		set
		{
			SetBoolField(BoolField.IsZStateDiverse, value);
		}
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.Panel" /> class.</summary>
	protected Panel()
	{
		_zConsonant = (int)ZIndexProperty.GetDefaultValue(base.DependencyObjectType);
	}

	/// <summary>Draws the content of a <see cref="T:System.Windows.Media.DrawingContext" /> object during the render pass of a <see cref="T:System.Windows.Controls.Panel" /> element. </summary>
	/// <param name="dc">The <see cref="T:System.Windows.Media.DrawingContext" /> object to draw.</param>
	protected override void OnRender(DrawingContext dc)
	{
		Brush background = Background;
		if (background != null)
		{
			Size renderSize = base.RenderSize;
			dc.DrawRectangle(background, null, new Rect(0.0, 0.0, renderSize.Width, renderSize.Height));
		}
	}

	/// <summary>This type or member supports the Windows Presentation Foundation (WPF) infrastructure and is not intended to be used directly from your code.</summary>
	/// <param name="value"> An object to add as a child.</param>
	void IAddChild.AddChild(object value)
	{
		if (value == null)
		{
			throw new ArgumentNullException("value");
		}
		if (IsItemsHost)
		{
			throw new InvalidOperationException(SR.Panel_BoundPanel_NoChildren);
		}
		if (!(value is UIElement element))
		{
			throw new ArgumentException(SR.Format(SR.UnexpectedParameterType, value.GetType(), typeof(UIElement)), "value");
		}
		Children.Add(element);
	}

	/// <summary>This type or member supports the Windows Presentation Foundation (WPF) infrastructure and is not intended to be used directly from your code.</summary>
	/// <param name="text"> A string to add to the object.</param>
	void IAddChild.AddText(string text)
	{
		XamlSerializerUtil.ThrowIfNonWhiteSpaceInAddText(text, this);
	}

	/// <summary>Determines whether the <see cref="P:System.Windows.Controls.Panel.Children" /> collection of a panel should be serialized.</summary>
	/// <returns>true if the <see cref="P:System.Windows.Controls.Panel.Children" /> collection should be serialized; otherwise, false. The <see cref="P:System.Windows.Controls.Panel.Children" /> collection is only serialized if it is not empty and not null.</returns>
	[EditorBrowsable(EditorBrowsableState.Never)]
	public bool ShouldSerializeChildren()
	{
		if (!IsItemsHost && Children != null && Children.Count > 0)
		{
			return true;
		}
		return false;
	}

	private static void OnIsItemsHostChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
	{
		((Panel)d).OnIsItemsHostChanged((bool)e.OldValue, (bool)e.NewValue);
	}

	/// <summary>Indicates that the <see cref="P:System.Windows.Controls.Panel.IsItemsHost" /> property value has changed.</summary>
	/// <param name="oldIsItemsHost">The old property value.</param>
	/// <param name="newIsItemsHost">The new property value.</param>
	protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost)
	{
		DependencyObject itemsOwnerInternal = ItemsControl.GetItemsOwnerInternal(this);
		ItemsControl itemsControl = itemsOwnerInternal as ItemsControl;
		Panel panel = null;
		if (itemsControl != null)
		{
			IItemContainerGenerator itemContainerGenerator = itemsControl.ItemContainerGenerator;
			if (itemContainerGenerator != null && itemContainerGenerator == itemContainerGenerator.GetItemContainerGeneratorForPanel(this))
			{
				panel = itemsControl.ItemsHost;
				itemsControl.ItemsHost = this;
			}
		}
		else if (itemsOwnerInternal is GroupItem groupItem)
		{
			IItemContainerGenerator generator = groupItem.Generator;
			if (generator != null && generator == generator.GetItemContainerGeneratorForPanel(this))
			{
				panel = groupItem.ItemsHost;
				groupItem.ItemsHost = this;
			}
		}
		if (panel != null && panel != this)
		{
			panel.VerifyBoundState();
		}
		VerifyBoundState();
	}

	/// <summary>Gets a <see cref="T:System.Windows.Media.Visual" /> child of this <see cref="T:System.Windows.Controls.Panel" /> at the specified index position.</summary>
	/// <returns>A <see cref="T:System.Windows.Media.Visual" /> child of the parent <see cref="T:System.Windows.Controls.Panel" /> element.</returns>
	/// <param name="index">The index position of the <see cref="T:System.Windows.Media.Visual" /> child.</param>
	protected override Visual GetVisualChild(int index)
	{
		if (_uiElementCollection == null)
		{
			throw new ArgumentOutOfRangeException("index", index, SR.Visual_ArgumentOutOfRange);
		}
		if (IsZStateDirty)
		{
			RecomputeZState();
		}
		int index2 = ((_zLut != null) ? _zLut[index] : index);
		return _uiElementCollection[index2];
	}

	/// <summary>Creates a new <see cref="T:System.Windows.Controls.UIElementCollection" />.</summary>
	/// <returns>An ordered collection of elements that have the specified logical parent.</returns>
	/// <param name="logicalParent">The logical parent element of the collection to be created.</param>
	protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent)
	{
		return new UIElementCollection(this, logicalParent);
	}

	private bool VerifyBoundState()
	{
		if (ItemsControl.GetItemsOwnerInternal(this) != null)
		{
			if (_itemContainerGenerator == null)
			{
				ClearChildren();
			}
			return _itemContainerGenerator != null;
		}
		if (_itemContainerGenerator != null)
		{
			DisconnectFromGenerator();
			ClearChildren();
		}
		return false;
	}

	internal static bool IsAboutToGenerateContent(Panel panel)
	{
		if (panel.IsItemsHost)
		{
			return panel._itemContainerGenerator == null;
		}
		return false;
	}

	private void ConnectToGenerator()
	{
		IItemContainerGenerator itemContainerGenerator = (ItemsControl.GetItemsOwner(this) ?? throw new InvalidOperationException(SR.Panel_ItemsControlNotFound)).ItemContainerGenerator;
		if (itemContainerGenerator != null)
		{
			_itemContainerGenerator = itemContainerGenerator.GetItemContainerGeneratorForPanel(this);
			if (_itemContainerGenerator != null)
			{
				_itemContainerGenerator.ItemsChanged += OnItemsChanged;
				((IItemContainerGenerator)_itemContainerGenerator).RemoveAll();
			}
		}
	}

	private void DisconnectFromGenerator()
	{
		_itemContainerGenerator.ItemsChanged -= OnItemsChanged;
		((IItemContainerGenerator)_itemContainerGenerator).RemoveAll();
		_itemContainerGenerator = null;
	}

	private void EnsureEmptyChildren(FrameworkElement logicalParent)
	{
		if (_uiElementCollection == null || _uiElementCollection.LogicalParent != logicalParent)
		{
			_uiElementCollection = CreateUIElementCollection(logicalParent);
		}
		else
		{
			ClearChildren();
		}
	}

	internal void EnsureGenerator()
	{
		if (_itemContainerGenerator == null)
		{
			ConnectToGenerator();
			EnsureEmptyChildren(null);
			GenerateChildren();
		}
	}

	private void ClearChildren()
	{
		if (_itemContainerGenerator != null)
		{
			((IItemContainerGenerator)_itemContainerGenerator).RemoveAll();
		}
		if (_uiElementCollection != null && _uiElementCollection.Count > 0)
		{
			_uiElementCollection.ClearInternal();
			OnClearChildrenInternal();
		}
	}

	internal virtual void OnClearChildrenInternal()
	{
	}

	internal virtual void GenerateChildren()
	{
		IItemContainerGenerator itemContainerGenerator = _itemContainerGenerator;
		if (itemContainerGenerator == null)
		{
			return;
		}
		using (itemContainerGenerator.StartAt(new GeneratorPosition(-1, 0), GeneratorDirection.Forward))
		{
			while (itemContainerGenerator.GenerateNext() is UIElement uIElement)
			{
				_uiElementCollection.AddInternal(uIElement);
				itemContainerGenerator.PrepareItemContainer(uIElement);
			}
		}
	}

	private void OnItemsChanged(object sender, ItemsChangedEventArgs args)
	{
		if (VerifyBoundState() && OnItemsChangedInternal(sender, args))
		{
			InvalidateMeasure();
		}
	}

	internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args)
	{
		switch (args.Action)
		{
		case NotifyCollectionChangedAction.Add:
			AddChildren(args.Position, args.ItemCount);
			break;
		case NotifyCollectionChangedAction.Remove:
			RemoveChildren(args.Position, args.ItemUICount);
			break;
		case NotifyCollectionChangedAction.Replace:
			ReplaceChildren(args.Position, args.ItemCount, args.ItemUICount);
			break;
		case NotifyCollectionChangedAction.Move:
			MoveChildren(args.OldPosition, args.Position, args.ItemUICount);
			break;
		case NotifyCollectionChangedAction.Reset:
			ResetChildren();
			break;
		}
		return true;
	}

	private void AddChildren(GeneratorPosition pos, int itemCount)
	{
		IItemContainerGenerator itemContainerGenerator = _itemContainerGenerator;
		using (itemContainerGenerator.StartAt(pos, GeneratorDirection.Forward))
		{
			for (int i = 0; i < itemCount; i++)
			{
				if (itemContainerGenerator.GenerateNext() is UIElement uIElement)
				{
					_uiElementCollection.InsertInternal(pos.Index + 1 + i, uIElement);
					itemContainerGenerator.PrepareItemContainer(uIElement);
				}
				else
				{
					_itemContainerGenerator.Verify();
				}
			}
		}
	}

	private void RemoveChildren(GeneratorPosition pos, int containerCount)
	{
		_uiElementCollection.RemoveRangeInternal(pos.Index, containerCount);
	}

	private void ReplaceChildren(GeneratorPosition pos, int itemCount, int containerCount)
	{
		IItemContainerGenerator itemContainerGenerator = _itemContainerGenerator;
		using (itemContainerGenerator.StartAt(pos, GeneratorDirection.Forward, allowStartAtRealizedItem: true))
		{
			for (int i = 0; i < itemCount; i++)
			{
				if (itemContainerGenerator.GenerateNext(out var isNewlyRealized) is UIElement uIElement && !isNewlyRealized)
				{
					_uiElementCollection.SetInternal(pos.Index + i, uIElement);
					itemContainerGenerator.PrepareItemContainer(uIElement);
				}
				else
				{
					_itemContainerGenerator.Verify();
				}
			}
		}
	}

	private void MoveChildren(GeneratorPosition fromPos, GeneratorPosition toPos, int containerCount)
	{
		if (!(fromPos == toPos))
		{
			int num = ((IItemContainerGenerator)_itemContainerGenerator).IndexFromGeneratorPosition(toPos);
			UIElement[] array = new UIElement[containerCount];
			for (int i = 0; i < containerCount; i++)
			{
				array[i] = _uiElementCollection[fromPos.Index + i];
			}
			_uiElementCollection.RemoveRangeInternal(fromPos.Index, containerCount);
			for (int j = 0; j < containerCount; j++)
			{
				_uiElementCollection.InsertInternal(num + j, array[j]);
			}
		}
	}

	private void ResetChildren()
	{
		EnsureEmptyChildren(null);
		GenerateChildren();
	}

	private bool GetBoolField(BoolField field)
	{
		return (_boolFieldStore & field) != 0;
	}

	private void SetBoolField(BoolField field, bool value)
	{
		if (value)
		{
			_boolFieldStore |= field;
		}
		else
		{
			_boolFieldStore &= (BoolField)(byte)(~(int)field);
		}
	}

	/// <summary>Invoked when the <see cref="T:System.Windows.Media.VisualCollection" /> of a visual object is modified.</summary>
	/// <param name="visualAdded">The <see cref="T:System.Windows.Media.Visual" /> that was added to the collection.</param>
	/// <param name="visualRemoved">The <see cref="T:System.Windows.Media.Visual" /> that was removed from the collection.</param>
	protected internal override void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved)
	{
		if (!IsZStateDirty)
		{
			if (IsZStateDiverse)
			{
				IsZStateDirty = true;
			}
			else if (visualAdded != null && (int)visualAdded.GetValue(ZIndexProperty) != _zConsonant)
			{
				IsZStateDirty = true;
			}
		}
		base.OnVisualChildrenChanged(visualAdded, visualRemoved);
		if (IsZStateDirty)
		{
			RecomputeZState();
			InvalidateZState();
		}
	}

	/// <summary>Sets the value of the <see cref="P:System.Windows.Controls.Panel.ZIndex" /> attached property for a given element.</summary>
	/// <param name="element">The element on which to apply the property value.</param>
	/// <param name="value">The order on the z-plane in which this element appears.</param>
	/// <exception cref="T:System.ArgumentNullException">The element is null.</exception>
	public static void SetZIndex(UIElement element, int value)
	{
		if (element == null)
		{
			throw new ArgumentNullException("element");
		}
		element.SetValue(ZIndexProperty, value);
	}

	/// <summary>Gets the value of the <see cref="P:System.Windows.Controls.Panel.ZIndex" /> property for a given element.</summary>
	/// <returns>The <see cref="P:System.Windows.Controls.Panel.ZIndex" /> position of the element.</returns>
	/// <param name="element">The element for which to retrieve the <see cref="P:System.Windows.Controls.Panel.ZIndex" /> value.</param>
	/// <exception cref="T:System.ArgumentNullException">The element is null.</exception>
	public static int GetZIndex(UIElement element)
	{
		if (element == null)
		{
			throw new ArgumentNullException("element");
		}
		return (int)element.GetValue(ZIndexProperty);
	}

	private static void OnZIndexPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
	{
		int num = (int)e.OldValue;
		int num2 = (int)e.NewValue;
		if (num != num2 && d is UIElement { InternalVisualParent: Panel internalVisualParent })
		{
			internalVisualParent.InvalidateZState();
		}
	}

	internal void InvalidateZState()
	{
		if (!IsZStateDirty && _uiElementCollection != null)
		{
			InvalidateZOrder();
		}
		IsZStateDirty = true;
	}

	private void RecomputeZState()
	{
		int num = ((_uiElementCollection != null) ? _uiElementCollection.Count : 0);
		bool flag = false;
		bool flag2 = false;
		int num2 = (int)ZIndexProperty.GetDefaultValue(base.DependencyObjectType);
		int num3 = num2;
		List<long> list = null;
		if (num > 0)
		{
			if (_uiElementCollection[0] != null)
			{
				num3 = (int)_uiElementCollection[0].GetValue(ZIndexProperty);
			}
			if (num > 1)
			{
				list = new List<long>(num);
				list.Add((long)num3 << 32);
				int num4 = num3;
				int num5 = 1;
				do
				{
					int num6 = ((_uiElementCollection[num5] != null) ? ((int)_uiElementCollection[num5].GetValue(ZIndexProperty)) : num2);
					list.Add(((long)num6 << 32) + num5);
					flag2 = flag2 || num6 < num4;
					num4 = num6;
					flag = flag || num6 != num3;
				}
				while (++num5 < num);
			}
		}
		if (flag2)
		{
			list.Sort();
			if (_zLut == null || _zLut.Length != num)
			{
				_zLut = new int[num];
			}
			for (int i = 0; i < num; i++)
			{
				_zLut[i] = (int)(list[i] & 0xFFFFFFFFu);
			}
		}
		else
		{
			_zLut = null;
		}
		IsZStateDiverse = flag;
		_zConsonant = num3;
		IsZStateDirty = false;
	}
}
