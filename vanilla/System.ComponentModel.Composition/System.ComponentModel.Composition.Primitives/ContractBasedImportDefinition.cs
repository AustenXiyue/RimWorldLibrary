using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using Microsoft.Internal;

namespace System.ComponentModel.Composition.Primitives;

/// <summary>Represents an import that is required by a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> object and that can specify both a contract name and metadata.</summary>
public class ContractBasedImportDefinition : ImportDefinition
{
	private readonly IEnumerable<KeyValuePair<string, Type>> _requiredMetadata = Enumerable.Empty<KeyValuePair<string, Type>>();

	private Expression<Func<ExportDefinition, bool>> _constraint;

	private readonly CreationPolicy _requiredCreationPolicy;

	private readonly string _requiredTypeIdentity;

	private bool _isRequiredMetadataValidated;

	/// <summary>Gets the expected type of the export that matches this <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />.</summary>
	/// <returns>A string that is generated by calling the <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> method on the type that this import expects. If the value is null, this import does not expect a particular type.</returns>
	public virtual string RequiredTypeIdentity => _requiredTypeIdentity;

	/// <summary>Gets the metadata names of the export required by the import definition.</summary>
	/// <returns>A collection of <see cref="T:System.String" /> objects that contain the metadata names of the <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> objects required by the <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" />. The default is an empty <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection.</returns>
	public virtual IEnumerable<KeyValuePair<string, Type>> RequiredMetadata
	{
		get
		{
			ValidateRequiredMetadata();
			return _requiredMetadata;
		}
	}

	/// <summary>Gets or sets a value that indicates that the importer requires a specific <see cref="T:System.ComponentModel.Composition.CreationPolicy" /> for the exports used to satisfy this import. </summary>
	/// <returns>One of the following values:<see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />, if the importer does not require a specific <see cref="T:System.ComponentModel.Composition.CreationPolicy" />.<see cref="F:System.ComponentModel.Composition.CreationPolicy.Shared" /> to require that all exports used should be shared by all importers in the container.<see cref="F:System.ComponentModel.Composition.CreationPolicy.NonShared" /> to require that all exports used should be non-shared in the container. In this case, each importer receives a separate instance.</returns>
	public virtual CreationPolicy RequiredCreationPolicy => _requiredCreationPolicy;

	/// <summary>Gets an expression that defines conditions that must be matched to satisfy the import described by this import definition.</summary>
	/// <returns>An expression that contains a <see cref="T:System.Func`2" /> object that defines the conditions that must be matched for the <see cref="T:System.ComponentModel.Composition.Primitives.ImportDefinition" /> to be satisfied by an <see cref="T:System.ComponentModel.Composition.Primitives.Export" />.</returns>
	public override Expression<Func<ExportDefinition, bool>> Constraint
	{
		get
		{
			if (_constraint == null)
			{
				_constraint = ConstraintServices.CreateConstraint(ContractName, RequiredTypeIdentity, RequiredMetadata, RequiredCreationPolicy);
			}
			return _constraint;
		}
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> class.</summary>
	protected ContractBasedImportDefinition()
	{
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> class with the specified contract name, required type identity, required metadata, cardinality, and creation policy, and indicates whether the import definition is recomposable or a prerequisite.</summary>
	/// <param name="contractName">The contract name of the <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> object required by the import definition.</param>
	/// <param name="requiredTypeIdentity">The type identity of the export type expected. Use the <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> method to generate a type identity for a given type. If no specific type is required, use null.</param>
	/// <param name="requiredMetadata">A collection of key/value pairs that contain the metadata names and types required by the import definition; or null to set the <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> property to an empty <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection.</param>
	/// <param name="cardinality">One of the enumeration values that indicates the cardinality of the <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> objects required by the import definition.</param>
	/// <param name="isRecomposable">true to specify that the import definition can be satisfied multiple times throughout the lifetime of a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; otherwise, false.</param>
	/// <param name="isPrerequisite">true to specify that the import definition is required to be satisfied before a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> can start producing exported objects; otherwise, false.</param>
	/// <param name="requiredCreationPolicy">A value that indicates that the importer requires a specific creation policy for the exports used to satisfy this import. If no specific creation policy is needed, the default is <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />.</param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="contractName" /> is null.</exception>
	/// <exception cref="T:System.ArgumentException">
	///   <paramref name="contractName" /> is an empty string ("").-or-<paramref name="requiredMetadata" /> contains an element that is null.-or-<paramref name="cardinality" /> is not one of the <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" /> values.</exception>
	public ContractBasedImportDefinition(string contractName, string requiredTypeIdentity, IEnumerable<KeyValuePair<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy)
		: this(contractName, requiredTypeIdentity, requiredMetadata, cardinality, isRecomposable, isPrerequisite, requiredCreationPolicy, MetadataServices.EmptyMetadata)
	{
	}

	/// <summary>Initializes a new instance of the <see cref="T:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition" /> class with the specified contract name, required type identity, required and optional metadata, cardinality, and creation policy, and indicates whether the import definition is recomposable or a prerequisite.</summary>
	/// <param name="contractName">The contract name of the <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> object required by the import definition.</param>
	/// <param name="requiredTypeIdentity">The type identity of the export type expected. Use the <see cref="M:System.ComponentModel.Composition.AttributedModelServices.GetTypeIdentity(System.Type)" /> method to generate a type identity for a given type. If no specific type is required, use null.</param>
	/// <param name="requiredMetadata">A collection of key/value pairs that contain the metadata names and types required by the import definition; or null to set the <see cref="P:System.ComponentModel.Composition.Primitives.ContractBasedImportDefinition.RequiredMetadata" /> property to an empty <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection.</param>
	/// <param name="cardinality">One of the enumeration values that indicates the cardinality of the <see cref="T:System.ComponentModel.Composition.Primitives.Export" /> objects required by the import definition.</param>
	/// <param name="isRecomposable">true to specify that the import definition can be satisfied multiple times throughout the lifetime of a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" />; otherwise, false.</param>
	/// <param name="isPrerequisite">true to specify that the import definition is required to be satisfied before a <see cref="T:System.ComponentModel.Composition.Primitives.ComposablePart" /> can start producing exported objects; otherwise, false.</param>
	/// <param name="requiredCreationPolicy">A value that indicates that the importer requires a specific creation policy for the exports used to satisfy this import. If no specific creation policy is needed, the default is <see cref="F:System.ComponentModel.Composition.CreationPolicy.Any" />.</param>
	/// <param name="metadata">The metadata associated with this import.</param>
	/// <exception cref="T:System.ArgumentNullException">
	///   <paramref name="contractName" /> is null.</exception>
	/// <exception cref="T:System.ArgumentException">
	///   <paramref name="contractName" /> is an empty string ("").-or-<paramref name="requiredMetadata" /> contains an element that is null.-or-<paramref name="cardinality" /> is not one of the <see cref="T:System.ComponentModel.Composition.Primitives.ImportCardinality" /> values.</exception>
	public ContractBasedImportDefinition(string contractName, string requiredTypeIdentity, IEnumerable<KeyValuePair<string, Type>> requiredMetadata, ImportCardinality cardinality, bool isRecomposable, bool isPrerequisite, CreationPolicy requiredCreationPolicy, IDictionary<string, object> metadata)
		: base(contractName, cardinality, isRecomposable, isPrerequisite, metadata)
	{
		Requires.NotNullOrEmpty(contractName, "contractName");
		_requiredTypeIdentity = requiredTypeIdentity;
		if (requiredMetadata != null)
		{
			_requiredMetadata = requiredMetadata;
		}
		_requiredCreationPolicy = requiredCreationPolicy;
	}

	private void ValidateRequiredMetadata()
	{
		if (_isRequiredMetadataValidated)
		{
			return;
		}
		foreach (KeyValuePair<string, Type> requiredMetadatum in _requiredMetadata)
		{
			if (requiredMetadatum.Key == null || requiredMetadatum.Value == null)
			{
				throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture, Strings.Argument_NullElement, "requiredMetadata"));
			}
		}
		_isRequiredMetadataValidated = true;
	}

	/// <summary>Returns a value indicating whether the constraint represented by this object is satisfied by the export represented by the given export definition.</summary>
	/// <returns>true if the constraint is satisfied; otherwise, false.</returns>
	/// <param name="exportDefinition">The export definition to test.</param>
	public override bool IsConstraintSatisfiedBy(ExportDefinition exportDefinition)
	{
		Requires.NotNull(exportDefinition, "exportDefinition");
		if (!StringComparers.ContractName.Equals(ContractName, exportDefinition.ContractName))
		{
			return false;
		}
		return MatchRequiredMatadata(exportDefinition);
	}

	private bool MatchRequiredMatadata(ExportDefinition definition)
	{
		if (!string.IsNullOrEmpty(RequiredTypeIdentity))
		{
			string value = definition.Metadata.GetValue<string>("ExportTypeIdentity");
			if (!StringComparers.ContractName.Equals(RequiredTypeIdentity, value))
			{
				return false;
			}
		}
		foreach (KeyValuePair<string, Type> requiredMetadatum in RequiredMetadata)
		{
			string key = requiredMetadatum.Key;
			Type value2 = requiredMetadatum.Value;
			object value3 = null;
			if (!definition.Metadata.TryGetValue(key, out value3))
			{
				return false;
			}
			if (value3 != null)
			{
				if (!value2.IsInstanceOfType(value3))
				{
					return false;
				}
			}
			else if (value2.IsValueType)
			{
				return false;
			}
		}
		if (RequiredCreationPolicy == CreationPolicy.Any)
		{
			return true;
		}
		CreationPolicy value4 = definition.Metadata.GetValue<CreationPolicy>("System.ComponentModel.Composition.CreationPolicy");
		if (value4 != 0)
		{
			return value4 == RequiredCreationPolicy;
		}
		return true;
	}

	/// <returns>Returns <see cref="T:System.String" />.</returns>
	public override string ToString()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append($"\n\tContractName\t{ContractName}");
		stringBuilder.Append($"\n\tRequiredTypeIdentity\t{RequiredTypeIdentity}");
		if (_requiredCreationPolicy != 0)
		{
			stringBuilder.Append($"\n\tRequiredCreationPolicy\t{RequiredCreationPolicy}");
		}
		if (_requiredMetadata.Count() > 0)
		{
			stringBuilder.Append($"\n\tRequiredMetadata");
			foreach (KeyValuePair<string, Type> requiredMetadatum in _requiredMetadata)
			{
				stringBuilder.Append($"\n\t\t{requiredMetadatum.Key}\t({requiredMetadatum.Value})");
			}
		}
		return stringBuilder.ToString();
	}
}
